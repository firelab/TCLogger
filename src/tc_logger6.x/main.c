/*---------------------------------------------------------------*/
/* FAT file system module test program            (C)ChaN, 2013  */
/*---------------------------------------------------------------*/
 
#include "string.h"
#include "p24hj128gp202.h"
#include "pic24h.h"
//#include "uart_pic24h.h"
#include "xprintf.h"
#include "diskio.h"
#include "ff.h"
#include "ad_pic24h.h"
#include "stdio.h"
#include "gps_pic24h.h"
#include "stdlib.h"
#include "logger_pic24h.h"
#include "rtcc_pic24h.h"

//#include "xc.h"

// FBS
#pragma config BWRP = WRPROTECT_OFF     // Boot Segment Write Protect (Boot Segment may be written)
#pragma config BSS = NO_FLASH           // Boot Segment Program Flash Code Protection (No Boot program Flash segment)
#pragma config RBS = NO_RAM             // Boot Segment RAM Protection (No Boot RAM)

// FSS
#pragma config SWRP = WRPROTECT_OFF     // Secure Segment Program Write Protect (Secure segment may be written)
#pragma config SSS = NO_FLASH           // Secure Segment Program Flash Code Protection (No Secure Segment)
#pragma config RSS = NO_RAM             // Secure Segment Data RAM Protection (No Secure RAM)

// FGS
#pragma config GWRP = OFF               // General Code Segment Write Protect (User program memory is not write-protected)
#pragma config GSS = OFF                // General Segment Code Protection (User program memory is not code-protected)

// FOSCSEL
#pragma config FNOSC = PRIPLL           // Oscillator Mode (Primary Oscillator (XT, HS, EC) w/ PLL)
#pragma config IESO = ON                // Internal External Switch Over Mode (Start-up device with FRC, then automatically switch to user-selected oscillator source when ready)

// FOSC
#pragma config POSCMD = EC              // Primary Oscillator Source (HS Oscillator Mode)
#pragma config OSCIOFNC = ON            // OSC2 Pin Function (OSC2 pin has digital I/O function)
#pragma config IOL1WAY = OFF            // Peripheral Pin Select Configuration (Allow Multiple Re-configurations)
#pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Both Clock Switching and Fail-Safe Clock Monitor are disabled)

// FWDT
#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler (1:32,768)
#pragma config WDTPRE = PR128           // WDT Prescaler (1:128)
#pragma config WINDIS = OFF             // Watchdog Timer Window (Watchdog Timer in Non-Window mode)
#pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog timer enabled/disabled by user software)

// FPOR
#pragma config FPWRT = PWR128           // POR Timer Value (128ms)
#pragma config ALTI2C = OFF             // Alternate I2C  pins (I2C mapped to SDA1/SCL1 pins)

// FICD
#pragma config ICS = PGD1               // Comm Channel Select (Communicate on PGC1/EMUC1 and PGD1/EMUD1)
#pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG is Disabled)

//typedef unsigned char bool;
#define true    1
#define false   0

#define button   _RB10
#define led_on   _LATB11 = 1
#define led_off  _LATB11 = 0
#define pps      _RA3



DWORD AccSize;			/* Work register for fs command */
WORD AccFiles, AccDirs;
FILINFO Finfo;
#if _USE_LFN
TCHAR Lfname[256];
#endif


char Line[256];			/* Console input buffer */

FATFS FatFs;			/* File system object */
FIL File[2];			/* File objects */
char Buff[1024]; /* Working buffer */

char gps_tx_buff[1024];
char gps_rx_buff[1024];
DWORD ADBuffer[8];
bool Sec_Pulse = false;
bool flash = false;
char _error = 1;

volatile UINT Timer,Timer4,Timer5,div1k;	/* 1kHz increment timer */
volatile WORD rtcYear = 2016;
volatile BYTE rtcMon = 9, rtcMday = 26, rtcHour = 16, rtcMin = 59, rtcSec = 15;
void led_timerproc (void);
DWORD ms;
//_FUID1(0);  //SN = 256 * FUID1 + FUID0
//_FUID0(14);

struct logger_setup ls = {20,1,1,1,1,1,1,1,1};

/*---------------------------------------------------------*/
/* 1000Hz timer interrupt generated by Timer1              */
/*---------------------------------------------------------*/

void __attribute__((interrupt, auto_psv)) _T1Interrupt (void)
{
	static const BYTE samurai[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	//static UINT div1k;
	BYTE n;


	_T1IF = 0;			/* Clear irq flag */
	Timer++;			/* Performance counter for this module */
//	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
//        ad_timerproc();         /* timer3 */
        led_timerproc();
        gps_timerproc();
        loop_timerproc(); //Timer4 in main
	/* Real Time Clock */
	if (++div1k >= 1000) {
		div1k = 0;
        flash = true;
        if (++rtcSec >= 60) {
			rtcSec = 0;
			if (++rtcMin >= 60) {
				rtcMin = 0;
				if (++rtcHour >= 24) {
					rtcHour = 0;
					n = samurai[rtcMon - 1];
					if ((n == 28) && !(rtcYear & 3)) n++;
					if (++rtcMday > n) {
						rtcMday = 1;
						if (++rtcMon > 12) {
							rtcMon = 1;
							rtcYear++;
						}
					}
				}
			}
		}
	}
}

/*---------------------------------------------------------*/
/* User Provided RTC Function for FatFs module             */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support an RTC.                     */
/* This function is not required in read-only cfg.         */

DWORD get_fattime (void)
{
	DWORD tmr;


	_DI();
	/* Pack date and time into a DWORD variable */
	tmr =	  (((DWORD)rtcYear - 1980) << 25)
			| ((DWORD)rtcMon << 21)
			| ((DWORD)rtcMday << 16)
			| (WORD)(rtcHour << 11)
			| (WORD)(rtcMin << 5)
			| (WORD)(rtcSec >> 1); /* 2 seconds*/
	_EI();

	return tmr;
}
       
    

/*-----------------------------------------------------------------------*/
/* Device Timer Driven Procedure                                         */
/*-----------------------------------------------------------------------*/
/* This function must be called by timer interrupt in period of 1ms      */
/******************************************************************************/
void loop_timerproc (void)
/******************************************************************************/
{
	/*BYTE s;*/
	UINT n;

	n = Timer4;					/* 1000Hz decrement timer with zero stopped */
	if (n) Timer4 = --n;

}
/******************************************************************************/
void led_timerproc (void)
/******************************************************************************/
{
    UINT n;

    n = Timer5;
    if (n) Timer5 = --n;
}
/******************************************************************************/
static float GetPanelTemp(void)   //get LM20 temperature sensor value 
/******************************************************************************/
{
    WORD ADCResult;
    float ADCVolts, Panel_Temp;
    const float Vref = 3.30;
    
_CH0SA = 0;                                 //select AN0
AD1CON1bits.SAMP = 0;                       //enable sample 
while(!AD1CON1bits.DONE)                    //wait for "DONE" flag
ADCResult = ADC1BUF0;                       //put A/D result in ADCResult
ADCVolts = ADCResult/4095.0 * Vref;         //convert A/D result to engineering units
//Panel_Temp = ADCResult/4095.0 * Vref;         //convert A/D result to engineering units
//Panel_Temp = 154.49 - 84.12 * ADCVolts;     //convert engineering units to temperature
Panel_Temp = 154.0 - 84.12 * ADCVolts;
//Panel_Temp = 26.0;
return Panel_Temp;
}

/******************************************************************************/
static float GetBatteryVolts(void)
/******************************************************************************/
{
    WORD ADCResult;
    float ADCVolts;
    const float Vref = 3.30;
    
_CH0SA = 2;                                 //select AN2 connected to battery    
AD1CON1bits.SAMP = 0;                       //enable sample 
while(!AD1CON1bits.DONE)                    //wait for "DONE" flag
ADCResult = ADC1BUF0;                       //put A/D result in ADCResult
ADCVolts = ADCResult/4095.0 * Vref ;  //convert A/D result to engineering units
                                            //calculated voltage is 12% low, thus the multiplier
return ADCVolts;
}


/******************************************************************************/
static float process_ad(          // process ad7173 readings 
/******************************************************************************/
DWORD *adres,
float *pnltemp,
BYTE measurement
)
{
  float value, mV, ColdJctmV;
  
  if (measurement == 0) //process temperature
  {  
  mV = ((((float) *adres/16777215.0) * 2.50) - 1.25) * 2000.0; // convert A/D result to mV
  ColdJctmV = 0.01805158 + (*pnltemp) * 0.04068923 ;
  mV += ColdJctmV;
  if (mV < 6.139)
  {
      value = (-0.0047 + mV * (25.399 + mV * (-0.4359 + mV * (0.0478))));
  }
  else
  {
      value = (-6.4969 + mV * (26.248 + mV * (-0.1208 + mV * (0.0018)))); //convert mV to Temp.
  }
//  value = (-1.7120513 + mV * (25.647427 + mV * (-0.10006202 + mV * (0.0016138382)))); //convert mV to Temp.
  //value = 25.0;
  }
  else
  {
   value = ((((float) *adres/16777215.0) * 2.50) - 1.25) * 2.0; // convert A/D result to Volts
   //value = 1.0; 
  
  }
  return (float) value;
}


/******************************************************************************/
static void flash_error(char error_code)
/******************************************************************************/
{
    char i;
    
    led_on;        //led on for 1 second
    Timer4 = 1000;
    while(Timer4){;}
    led_off;        //led off for 300ms
    Timer4 = 300;
    while(Timer4){;}
    
    for( i = 0; i < error_code; i++)
    {
        led_on;        //led on for 100ms
        Timer4 = 200;
        while(Timer4){;}
        led_off;        //led off for 100ms
        Timer4 = 200;
        while(Timer4){;}
    }
    Timer4 = 2000;          //wait 2 seconds before leaving
    while(Timer4){;}

}

/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */
/*--------------------------------------------------------------------------*/
/******************************************************************************/
//static void put_rc (FRESULT rc)
///******************************************************************************/
//{
//	const char *str =
//		"OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
//		"INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
//		"INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
//		"LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
//	FRESULT i;
//
//	for (i = 0; i != rc && *str; i++) {
//		while (*str++) ;
//	}
////	xprintf("rc=%u FR_%s\n", (UINT)rc, str);
//}
//

/******************************************************************************/
//static FRESULT scan_files (
///******************************************************************************/
//	char* path		/* Pointer to the path name working buffer */
//)
//{
//	DIR dirs;
//	FRESULT res;
//	int i;
//	char *fn;
//
//
//	if ((res = f_opendir(&dirs, path)) == FR_OK) {
//		i = strlen(path);
//		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
//			if (_FS_RPATH && Finfo.fname[0] == '.') continue;
//#if _USE_LFN
//			fn = *Finfo.lfname ? Finfo.lfname : Finfo.fname;
//#else
//			fn = Finfo.fname;
//#endif
//			if (Finfo.fattrib & AM_DIR) {
//				AccDirs++;
//				path[i] = '/'; strcpy(&path[i+1], fn);
//				res = scan_files(path);
//				path[i] = 0;
//				if (res != FR_OK) break;
//			} else {
//#if 0
//	//			xprintf("%s/%s\n", path, fn);
//#endif
//				AccFiles++;
//				AccSize += Finfo.fsize;
//			}
//		}
//	}
//
//	return res;
//}
/******************************************************************************/
static void IoInit (void)
/******************************************************************************/

{
    
    _RP8R = __SDO1;    // RPOR4:RP8R = 0x0A (SDO1)
    _RP7R = __SCK1;     // RPOR3:RP7R  = 0x0B (SCK1)
    _RP4R = __SDO2;     // RPOR2:RP4R  = 0x07 (SDO2)
    _RP3R = __SCK2;     // RPOR1:RP3R  = 0x08 (SCK2)
    _SDI1R = __RP6;    // RPINR22:SDI2R = 0x06 (RP6)
    _SDI2R = __RP5;     // RPINR20:SDI1R = 0x05 (RP5)
    AD1PCFGL = 0B1111111111111010;      // AN0 and AN2 configured as A/D input, all others digital
    TRISA = 0B00001011;  //ra0-an0 lm20,ra1 gps wakeup,ra3 1pps
    LATA =  0B00010000;
    TRISB = 0B1000010001100001; //rb15 u1rx,rb10 push button,rb6 sdi2,rb5 sdi1,rb0-an2 battery
    LATB =  0B0101001000011010; //0X540A;
   
   

    AD1CON1 = 0B1011010000000110; // results right justified, 12 bit, start conversion by clearing AD1CON<1>
    AD1CON2 = 0X00; // vref = vdd
    AD1CON3 = 0B0000000111111111; //auto sample time = 1Tad, Tad = 75ns
    AD1CON4 = 0X00; //one word in buffer for each analog input        
    
   
//    _U1RXR = __RP15;     // RPINR18:U1RXR = 0x0f (RP15)
//    _RP13R = __U1TX;    // RPOR6:RP13R = 0x03 (U1TX)
    
    
  // set Fosc to 80MHz 
  // Fosc = Fin * M / (N1 * N2)
  // N1 = 2, CLKDIV:PLLPRE<4:0> = 00000, default
    _PLLPOST = 0x00; // N2 = 2
    PLLFBD = 0x01E;  // M = 32 for 10MHz oscillator so PLLFBD = 30

    /* Start Timer1 with interval time of 1ms */

    PR1 = (FCY / 8 / 1000) - 1;  // period register count to produce 1ms period, countdown time is PR1 + 1 so subtract 1 for the correct time
    _TCKPS0 = 1;            /* Select prescaler Fcy/8 */
    _IPL = 1;           /* CPU interrupt priority is 1 */
    _CNIP = 1;          /* Change Notice interrupt priority is 1, <= CPU priority will cause the uC to continue
                         *  with the next instruction when waking from sleep */
    _CN16IE = 1;        /* enable RB10, CN16, push button for change notice interrupt */    
    _CNIF = 0;          /* make sure there is no change notice interrupt */
    _TON = 1;		/* Start Timer1 */
    _T1IE = 1;		/* Enable Timer1 interrupt */

    _EI();


}
/******************************************************************************/
static void logger_initialize (void)
/******************************************************************************/
{
    FRESULT fr;
    UINT s2;
    
    
    if(f_open(&File[0], "LOGGER.CFG", FA_READ))
    {
        _error = 3;
        flash_error(_error);
    }   // flash error 3 for no file, use default configuration
    else
    {                            //open logger.cfg to read as file 0
    while(!f_eof(&File[0])){
        f_read(&File[0],Buff,50,&s2);
    }
    logger_init(Buff,50, &ls);
    fr = f_close(&File[0]);     //close file 0, logger.cfg
    }
}
    
/******************************************************************************/    
static void file_initialize (char* FileName)
/******************************************************************************/
{
    FRESULT fr;
//    char str[10];
//    str[0] = 0;
//
//    xsprintf(FileName,"%d.DAT",SN);
//    xprintf("file name = %s\n",str);
    fr = f_open(&File[0], FileName, FA_CREATE_NEW);    //open "SN".dat as file 0, create if not present
    fr = f_close(&File[0]);  //close file 0, logdata.dat

}
/******************************************************************************/
static void disk_mount (void)
/******************************************************************************/
{
    FRESULT fr;
    
    while (disk_initialize(0)) {flash_error(2);}        //flash error 2 if disk is absent
    fr = f_mount(&FatFs, "", 0); /* mount the drive */
}

/******************************************************************************/
void gps_buffer_dump(const BYTE* buffer, const UINT num_bytes)
/******************************************************************************/
{
    UINT bytes_per_row = 16;
    UINT num_rows = num_bytes / bytes_per_row;
    UINT address_offset_header = 0;
    UINT offset = 0;
    UINT row = 0;

    for (row = 0; row < num_rows; row++)
    {
        /* Address Row Header */
        address_offset_header = row * bytes_per_row;
   //     xprintf("%08X: ", (address_offset_header));

        /* Hexadecimal dump */
        for (offset = 0; offset < bytes_per_row; offset++)
        {
   //         xprintf(" %02X", (const char*)buffer[address_offset_header + offset]);
        }
   //     xprintf("  ");

        /* ASCII dump */
        for (offset = 0; offset < bytes_per_row; offset++)
        {
            /* Ignore junk data */
            if( (buffer[address_offset_header + offset] == 0x0A) ||
                (buffer[address_offset_header + offset] == 0x0D) ||
                (buffer[address_offset_header + offset] == 0xA7) ||
                (buffer[address_offset_header + offset] == 0xB4))
            {
   //             xprintf(".");
            }
            /* Print out ASCII of good data */
            else
            {
    //            xprintf("%c", (const char*)buffer[address_offset_header + offset]);
            }
        }
   //     xprintf("\n");
    }
  //  xprintf("\n");
}

/******************************************************************************/
void __attribute__ ((interrupt, auto_psv)) _CNInterrupt(void) //button interrupt
/******************************************************************************/
{
    // insert ISR code here
    //button was pressed
    
    _CNIF = 0;      /* clear CN interrupt */
    
}
/******************************************************************************/
/******************************************************************************/
int main (void)
/******************************************************************************/
/******************************************************************************/
{
    const UINT NUM_BYTES = 1024;
    

	

    BYTE  chan, index;
//	const BYTE ft[] = {0,12,16,32};
	UINT  bw,i,  si, j;
	DWORD  adres = 0;
	FRESULT  fr;
    
//	FATFS *fs;				/* Pointer to file system object */
//	DIR dir;				/* Directory object */
    float EngUnits;
    float Panel_Temp, Battery_Volts;
    
//    data_record Record_Buffer[9]; /*8 A/D channels + panel temp. */
    BYTE Record_Buffer[45];
    char Header_Buffer[48];
    ldiv_t Month_Day, Month, Year, Hours, Minutes, Seconds, SN ;
    
    short find_message_success = 0;
//    UINT set_time = 0;
    
//    bool is_message_received = false;
//    bool is_gga_received = false;
//    bool is_end_of_gga_found = false;
//    bool is_valid_checksum = false;
    bool BatteryLow = false;

//    const UINT LATITUDE_SIZE = 9;
//    const UINT LONGITUDE_SIZE = 10;
//    const UINT UTC_TIME_SIZE = 10;
//    const UINT UT_DATE_SIZE = 6;
//    const UINT SATELLITES_SIZE = 2;

    char utc_time[10] = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30 };
    BYTE gprmc_validity[1] = { 0x30 };
    BYTE latitude[9] = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};
    BYTE north_or_south[1] = { 0x30 };
    BYTE longitude[10] = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};
    BYTE east_or_west[1] = { 0x30 };
    BYTE ut_date[6] = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30 };
    BYTE fix_validity[1] = {0x30};
    char satellites[2] = "00";
    //DWORD debug;
    char FileName[10];
    FileName[0] = 0;
//    INT x;
    int iDatal, iDatah, iData;    
    RTCC_DATETIME rtcc_DateTime;
    char rtccYear,rtccMon,rtccMday,rtccHour,rtccMin,rtccSec,rtccCont,rtccCal,rtccCalSgn;
    BYTE pass = 0;
//    static const BYTE Month_Days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    TBLPAG = 0xF8;
    unsigned char const *TempPtr = (unsigned char const*)(&EngUnits); //*TempPtr points to the Volts memory location
    unsigned char const *PanelTempPtr = (unsigned char const*)(&Panel_Temp);  //point to the location of the panel temp
 //   unsigned char const *BatteryVoltsPtr = (unsigned char const*)(&Battery_Volts); //point to location of the battery voltage
/******************************************************************************/
/************** initialize peripherals ****************************************/
/******************************************************************************/ 
    for(;;){
    IoInit();
 
    led_on;
    led_off;
//   for(;;){
//    led_on;
//    Timer4 = 500;
//    while(Timer4){;}
//    led_off;
//    Timer4 = 500;
//    while(Timer4){;}
//    }    
    
   led_on;
   led_off;


disk_mount();
logger_initialize();
  
rtcc_osc_on();   
 
    

    rtccSec = 59;
    while (rtccSec == 59)
    {
    RTCC_TimeGet(&rtcc_DateTime);

    rtccYear = rtcc_DateTime.year;
    rtccMon = rtcc_DateTime.month;
    rtccMday = rtcc_DateTime.day;
    rtccHour = rtcc_DateTime.hour;
    rtccMin = rtcc_DateTime.minute;
    rtccSec = rtcc_DateTime.second;
    }

    RTCC_TimeGet (&rtcc_DateTime);
    rtcYear = rtcc_DateTime.year + 0x7d0;
    rtcMon = rtcc_DateTime.month;
    rtcMday = rtcc_DateTime.day;
    rtcHour = rtcc_DateTime.hour;
    rtcMin = rtcc_DateTime.minute;
    rtcSec = rtcc_DateTime.second;
    rtccCont = rtcc_DateTime.cont;
    rtccCal = rtcc_DateTime.cal;
    rtccCalSgn = rtcc_DateTime.calsgn;


    
        iDatal = __builtin_tblrdl(0x0010);  // read serial number
        iDatah = __builtin_tblrdl(0x0012);
        iData = iDatal + iDatah * 256;
        xsprintf(FileName, "%d.DAT", iData); 

#if _USE_LFN	/* Initialize file info structure if in LFN cfg */
	Finfo.lfname = Lfname;
	Finfo.lfsize = sizeof Lfname;
#endif
    
/******************************************************************************/
/***************** initialize files *******************************************/
/******************************************************************************/    
      
    file_initialize(FileName);
    
    find_message_success = 0;
 
/******************************************************************************/    
/**************test for open TC ***********************************************/
/******************************************************************************/
ADInputTest();  //burnout detection enabled

Timer4 = 2000;          //wait 2 seconds to allow the ADC to settle
while(Timer4){;}        //before checking for open thermocouples,

get_ad_chan(ADBuffer);    //read eight channels and check for open thermocouples
  
 //   unsigned char const *TempPtr = (unsigned char const*)(&EngUnits); //*TempPtr points to the Volts memory location
    for(i=0;i<8;i++)                                //process 8 channels of A/D results
    {    
        chan = (ADBuffer[i] & 0x000F) + 1;          //get the channel number located in the lower nibble
        adres = ADBuffer[i] >> 8;                   //get 24 bit A/D result by shifting right to get rid of chan numb.
        
        EngUnits = process_ad(&adres,&Panel_Temp,(BYTE) ls.measurand[chan - 1]); //convert the A/D result to engineering units
                                                                                 //ieee754 format requires 4 bytes so record is 4 bytes + 1 byte channel number
        if ((ls.measurand[chan - 1] == 0) && (EngUnits > 2000.0)){_error = 5;}
        
//        printf("AD#:%u, Reading: %f\n\r",(BYTE)chan,EngUnits);
        
    } 
    
if(_error == 5){flash_error(_error);} //report any open TCs
    
/******************************************************************************/    
/******************************************************************************/
ad_init(); /* re-initialize the a/d turning off input burnout test */
/******************************************************************************/
/******************************************************************************/



/******************************************************************************/
/***** read the battery voltage and report if it's below 2.5V *****************/    
/******************************************************************************/    
//    unsigned char const *BatteryVoltsPtr = (unsigned char const*)(&Battery_Volts);
    Battery_Volts = GetBatteryVolts();
//    printf("Battery Voltage: %f\n\r",Battery_Volts);
    if(Battery_Volts <= 2.5){_error = 4;}
    if(_error == 4){flash_error(_error);}
    
    
    flash_error(1); //report any file errors
       
//    for(;;){
//    led_on;
//    Timer4 = 500;
//    while(Timer4){;}
//    led_off;
//    Timer4 = 500;
//    while(Timer4){;}
//    } 
/*****************************************************************/    
/**** put uC to sleep and monitor button push to wake ***********/    
/*****************************************************************/    
    _CNIF = 0;
    _CN16IE = 1;      // enable CN on RB10
    _CNIE = 1;        // enable CN
//    AD1CON1bits.ADON = 0;  //disable the ADC module to reduce current draw during sleep
//    Timer4 = 1;
//    while (Timer4){;}
//    __asm__ volatile("REPEAT #50");  //wait 50 Tcy
//    __asm__ volatile("NOP");  //repeat NOP 51 times
    Sleep();          // hibernate the uC until CN on RB10 detected
//    AD1CON1bits.ADON = 1;  //enable ADC module
    _CNIF = 0;        // wake from sleep
    _CN16IE = 1;
    _CNIE = 0;       // disable CN            
    led_on;
                           
/**************************************************/
/************* initialize the gps *****************/
/**************************************************/
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_init();                                
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    send_zda_on();
    send_zda_on();

/******************************************************************************/
/************** search for satellites and get time and location ***************/
/******************************************************************************/
    Battery_Volts = GetBatteryVolts();
    while(button && (pass < 30) && (Battery_Volts > 1.90))                // push button to stop looking for satellites or time has been set
    {
        Battery_Volts = GetBatteryVolts();
        if (pass < 30)          // take 30 seconds to set clock
        {
            while(! pps && button){;}    // hold here while pps is low
                led_on;    // pps went high

                gps_fill_buffer(gps_rx_buff,NUM_BYTES); //get gps buffer
         //     gps_buffer_dump(gps_rx_buff,NUM_BYTES);
                gps_parse_zda(gps_rx_buff, NUM_BYTES, utc_time);    //get UTC time
                _DI();
                    div1k = (utc_time[9]-0x30)+10*(utc_time[8]-0x30)+100*(utc_time[7]-0x30); //set rtcc time
                    rtcSec = 10*(utc_time[4]-0x30)+(utc_time[5]-0x30);
                    rtcMin = 10*(utc_time[2]-0x30)+(utc_time[3]-0x30);
                    rtcHour = 10*(utc_time[0]-0x30)+(utc_time[1]-0x30);
                _EI();
                                                                 
                gps_parse_gga(gps_rx_buff, NUM_BYTES, utc_time,             //get # of satellites
                    latitude, north_or_south, longitude, east_or_west,      //get lat and long
                    fix_validity, satellites);
                gps_parse_rmc(gps_rx_buff, NUM_BYTES, utc_time,             //get date
                    gprmc_validity, latitude, north_or_south,               //get validity flag
                    longitude, east_or_west, ut_date);  // parse gprmc
                               
                                
                _DI(); 
                    rtcMday = 10*(ut_date[0]-0x30)+(ut_date[1]-0x30);
                    rtcMon = 10*(ut_date[2]-0x30)+(ut_date[3]-0x30);
                    rtcYear = 10*(ut_date[4]-0x30)+(ut_date[5]-0x30)+ 0x7d0; //set rtcc date
                _EI();   
                                
                if(gprmc_validity[0] == 0x56)
                    {
//                    xprintf("GPRMC GPS data is void!\n"); // gps data is invalid
                    led_off;
                    }
                else if(gprmc_validity[0] == 0x41)
                    {
/***********************set rtcc to gps time **********************************/
                    RTCC_TimeGet(&rtcc_DateTime);

                    rtccYear = rtcc_DateTime.year;
                    rtccMon = rtcc_DateTime.month;
                    rtccMday = rtcc_DateTime.day;
                    rtccHour = rtcc_DateTime.hour;
                    rtccMin = rtcc_DateTime.minute;
                    rtccSec = rtcc_DateTime.second;
//                    xprintf("rtcc time: %02u/%02u/%02u %02u:%02u:%02u\n", rtccYear, rtccMon, rtccMday, rtccHour, rtccMin, rtccSec);
//                    xprintf("GPRMC GPS data is valid!\n"); // gps data is valid
//                    xprintf(" ZDA Synced time is:\n");
//                    xprintf("gps time: %02u/%02u/%02u %02u:%02u:%02u.%03u\n", rtcYear, rtcMon, rtcMday, rtcHour, rtcMin, rtcSec, div1k);
//                    xprintf("GPRMC UTC time is ");
//                        for (i = 0; i < UT_DATE_SIZE; i++)
//                        {
//                            xprintf("%c", ut_date[i]);
//                        }
//                        xprintf("  ");
//                        for (i = 0; i < UTC_TIME_SIZE; i++)
//                        {
//                            xprintf("%c", utc_time[i]);
//                        }
//                                
//                        xprintf("\n");
//                               
//                        xprintf("Number of satellites is ");
//                        for (i = 0; i < SATELLITES_SIZE; i++)
//                        {
//                            xprintf("%c", satellites[i]);
//                        }
//                        xprintf("\n");

                        pass++;     // only increment pass when data is valid
                           
                    } // end data valid
                
                    
                    while(pps){;} // stay here until pps goes low
                    led_off;    // turn led off
                    if (pass >= 30)   // time acquired from gps, shut down gps
                    {
                        rtcc_DateTime.year = rtcYear%2000;
                        rtcc_DateTime.month = rtcMon;
                        rtcc_DateTime.day = rtcMday;
                        rtcc_DateTime.hour = rtcHour;
                        rtcc_DateTime.minute = rtcMin;
                        rtcc_DateTime.second = rtcSec;
                        RTCC_Initialize(&rtcc_DateTime);
                        
                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
                        gps_shutdown();
                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
                    } // gps shutdown

        } // do to here if pass < 30
                           
//        if (pass >= 30)
//        {          
//            if(flash)
//            {                // flash is set on rtcSec increment
//                led_on;             // pulse led
//                Timer4 = 50;
//                while(Timer4){;}
//                led_off;
//                flash = false;           // clear flash until next second increment
//                xprintf(" ZDA Synced time is:\n");
//                xprintf("%u/%u/%u %02u:%02u:%02u.%03u\n", rtcYear, rtcMon, rtcMday, rtcHour, rtcMin, rtcSec, div1k);
//            }  // end flash
//        }  // end pass >= 30
 
    } // do while RB10 true, pass < 30, and Battery > 1.5V loop
    
/***************************************************************************/    
/******************** shut down gps ****************************************/    
/***************************************************************************/    
    led_off;
    if (pass < 30){                         //satellite acquisistion skipped
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_shutdown();
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);
    gps_fill_buffer(gps_rx_buff,NUM_BYTES);

    /************** set logger time from rtcc ******************************/

    RTCC_TimeGet (&rtcc_DateTime);
    rtcYear = rtcc_DateTime.year + 0x7d0;
    rtcMon = rtcc_DateTime.month;
    rtcMday = rtcc_DateTime.day;
    rtcHour = rtcc_DateTime.hour;
    rtcMin = rtcc_DateTime.minute;
    rtcSec = rtcc_DateTime.second;
//    xprintf("Acquisition skipped, rtcc time: %02u/%02u/%02u %02u:%02u:%02u\n", rtcYear, rtcMon, rtcMday, rtcHour, rtcMin, rtcSec);
    } //if pass < 30
/*****************************************************************/
/******************** logger start *******************************/
/*****************************************************************/
pass = 0;  

/*****************************************************************/
/****************** write data file header ***********************/
/*****************************************************************/    
    Header_Buffer[0] = 'S';                         //write logger serial number to header buffer
    Header_Buffer[1] = 'N';
    SN = ldiv(iData,10000);
    Header_Buffer[2] = SN.quot + 0x30;
    iData = SN.rem;
    SN = ldiv(iData,1000);
    Header_Buffer[3] = SN.quot + 0x30;
    iData = SN.rem;
    SN = ldiv(iData,100);
    Header_Buffer[4] = SN.quot + 0x30;
    iData = SN.rem;
    SN = ldiv(iData,10);
    Header_Buffer[5] = SN.quot + 0x30;
    Header_Buffer[6] = SN.rem + 0x30;
    for(i=7;i<16;i++){
        Header_Buffer[i] = latitude[i-7];           //write latitude to buffer
    }
    Header_Buffer[i] = north_or_south[0];           //north or south
    for(i=17;i<27;i++){
        Header_Buffer[i] = longitude[i-17];         //write longitude to buffer
    }
    Header_Buffer[i] = east_or_west[0];             //east or west
    Header_Buffer[47] = ldiv(ls.ms,10).rem + 0x30;     //write sample interval to header, units
    si = ldiv(ls.ms,10).quot;                          //tens,hundreds,thousands
    Header_Buffer[46] = ldiv(si,10).rem + 0x30;     //tens
    si = ldiv(si,10).quot;                          //hundreds,thousands
    Header_Buffer[45] = ldiv(si,10).rem + 0x30;     //hundreds
    Header_Buffer[44] = ldiv(ls.ms,1000).quot + 0x30;  //thousands
    Year = ldiv(rtcYear,100);                       //write year to header//begin at start of new second
    Year = ldiv(Year.rem,10);
    Header_Buffer[28] = Year.quot + 0x30;
    Header_Buffer[29] = Year.rem + 0x30;
    Month = ldiv(rtcMon,10);                        //write month to header
    Header_Buffer[30] = Month.quot + 0x30;
    Header_Buffer[31] = Month.rem + 0x30;
    Month_Day = ldiv(rtcMday,10);                   //write day to header
    Header_Buffer[32] = Month_Day.quot + 0x30;
    Header_Buffer[33] = Month_Day.rem + 0x30;
    Hours = ldiv(rtcHour,10);                       //write hour to header
    Header_Buffer[34] = Hours.quot + 0x30;
    Header_Buffer[35] = Hours.rem + 0x30;
    Minutes = ldiv(rtcMin,10);                      //write minute to header
    Header_Buffer[36] = Minutes.quot + 0x30;
    Header_Buffer[37] = Minutes.rem + 0x30;
    while(div1k){;}                                 //synchronize overhead with second increment
    Timer4 = 1;                                     //wait 1ms for rtcc to update
    while(Timer4){;}
    Seconds = ldiv(rtcSec,10);                      //write second to header
    Header_Buffer[38] = Seconds.quot + 0x30;
    Header_Buffer[39] = Seconds.rem + 1 + 0x30;
    Header_Buffer[40] = '.';
    Header_Buffer[41] = 0x30;
    Header_Buffer[42] = 0x30;
    Header_Buffer[43] = 0x30;
    
                            
      
    fr = f_open(&File[0],FileName,FA_WRITE);    //open or create data file
    fr = f_lseek(&File[0],f_size(&File[0]));        //create pointer to end of file        
    fr = f_write(&File[0],Header_Buffer,48,&bw);    //write header to file

    while(div1k){;}                                 //loggers are out of sync at this point
                                                    //so synchronize at top of second
                                                    

/*************************************************************************/                          
/*************************** sample loop *********************************/    
/*************************************************************************/    
    Timer4 = ls.ms;
    while(button && !BatteryLow)   // sample until push button pressed or battery goes low
    {
   
    while(Timer4 && button && !BatteryLow)   //loop here until sample time times out
    {                                        //if sample time is less than 100ms
    if (ls.ms > 100)                         //nothing happens in this loop, but kill time
        {
            if(flash)
            {
                Timer5 = 20;  //flash is true so top of the second, set 20ms led timer
                Battery_Volts = GetBatteryVolts(); //battery volts gets refreshed every second
                if (Battery_Volts < 1.9){BatteryLow = true;}
            }  //flash is true once per second
            if(Timer5)
            {
                led_on; //top of the second so turn the led on
                flash = false;  //reset flash so it doesn't come on until top of next second
            } //if Timer5
            else   //not top of second so turn led off and keep off
            {
                led_off;
            }
        } //if ls.ms > 100
    } //Timer4 && button && !BatteryLow, wait for sample timer to time out
    
    Timer4 = ls.ms;  //sample time ran out above so re-initialize sample timer

    if(ls.ms <= 100)            //was sample time <=100ms? if so, take care of led he
    {
        if (flash){Timer5 = 20;}  //at the beginning of the rtc second, turn on led for 20ms

        if(Timer5)   //keep led on for 20ms every second and check the battery voltage
        {
            led_on;
            flash = false;      //set flash to false, will be here again next second
            Battery_Volts = GetBatteryVolts(); //battery volts gets refreshed every second
            if (Battery_Volts < 1.9){BatteryLow = true;}
        }
        else   //led timer ran out so turn led off and keep off
        {
            led_off;
        }

    }//if ls.ms <= 100
    get_ad_chan(ADBuffer);    //get 8 channels of A/D results
//
    Panel_Temp = GetPanelTemp();    //get the panel temp from the LM20
    Panel_Temp = GetPanelTemp();



   // unsigned char const *TempPtr = (unsigned char const*)(&EngUnits); //*TempPtr points to the Volts memory location
    for(i=0;i<8;i++)                                //process 8 channels of A/D results
    {
        chan = (ADBuffer[i] & 0x000F) + 1;          //get the channel number located in the lower nibble
        adres = ADBuffer[i] >> 8;                   //get 24 bit A/D result by shifting right to get rid of chan numb.

        EngUnits = process_ad(&adres,&Panel_Temp,(BYTE) ls.measurand[chan - 1]); //convert the A/D result to engineering units
                                    //ieee754 format requires 4 bytes so record is 4 bytes + 1 byte channel number
        index = i * 5;            //increment index by 5 to point at next record location in array
        for (j=0;j<4;j++){
            Record_Buffer[index + j] = TempPtr[j];  //store the record's 4 bytes in the buffer
        }
        Record_Buffer[index+4] = chan;              //store the chanel number in the buffer after the data value
        if(ls.ms >= 500)
        {
//        printf("AD#:%u, Reading: %f\n\r",(BYTE)chan,EngUnits);
        }

    }
   // unsigned char const *PanelTempPtr = (unsigned char const*)(&Panel_Temp);  //point to the location of the panel temp
   //unsigned char const *BatteryVoltsPtr = (unsigned char const*)(&Battery_Volts); //point to location of the battery voltage
    index = i * 5;
    for (j=0;j<4;j++){
        Record_Buffer[index + j] = PanelTempPtr[j]; //add panel temp to the record
    }
    Record_Buffer[index+4] = 0x00; //put 0 for the channel number

//
    fr = f_write(&File[0],Record_Buffer,45,&bw);    //write 8 channels of data to file

//    if (ls.ms >= 500)
//    {
//    printf("Panel Temp: %f\n\r",Panel_Temp);
//    printf("Battery Voltage: %f\n\r",Battery_Volts);
//    printf("\n\r");
//    }
    
    } //while button && !BatteryLow
    
    fr = f_close(&File[0]);
/***************************************************************************************/    
/********************** button pushed, put logger to sleep *****************************/
/***************************************************************************************/    
    led_on;        //flash led twice before shutting down
    Timer4 = 500;
    while (Timer4){;}
    led_off;
    Timer4 = 500;
    while (Timer4){;}
    led_on; 
    Timer4 = 500;
    while (Timer4){;}
    led_off;        //flash led twice before shutting down
    Timer4 = 500;
    while (Timer4){;}
    led_on;
    Timer4 = 500;
    while (Timer4){;}
    led_off;
//    AD1CON1bits.ADON = 0;  //disable the ADC module to reduce current draw during sleep
//    __asm__ volatile("REPEAT #50");  //wait 50 Tcy
//    __asm__ volatile("NOP");  //repeat NOP 51 times
    Sleep();          // hibernate the uC until power reboot 
                        
                 
    }                   
/******************************************************************/    
/************************* test routines **************************/
/******************************************************************/
//	for (;;) 
//    {
//       
//        
//        xputc('>');
//        
//        xgets(Line, sizeof Line);
//        ptr = Line;
//           
//		switch (*ptr++) 
//        {
////
///************** processor routines *****************/            
////
//            case 'p':
//                switch (*ptr++)
//                {
////
///*************** sleep *****************************/                    
////
//                    case 's'   :
//                         led_off;
//                         _CNIF = 0;
//                         _CN16IE = 1;
//                         _CNIE = 1;
//                        _pwrdwn();
//                        led_off;
//                        _CNIF = 0;
//                        _CN16IE = 1;
//                        _CNIE = 1;
//                        
//                        led_on;
//                        
//                        break;
//                }
////
///************** start of gps routines **************/            
////            
//            case 'g' :
//                switch (*ptr++) 
//                {
////
///************** initialize gps ************/                    
////                    
//                    case 'i' :
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_init(); // initialize the gps
//                    break;
////
///************** reset gps ***************/                    
////                    
//                    case 'r' :
//                        gps_reset();
//                        break;
////
///************** shut down gps **************/                        
////                        
//                    case 's' :
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_shutdown();
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        
//                    break;
////
///************** software id *************/                        
////
//                    case 'l' :
////                        
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        send_mid125(); 
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_buffer_dump(gps_rx_buff,NUM_BYTES);
//                                               
//                        break;
////
///************** turn GPGSV off *************/                        
////                  
//                       
//                    case 'v' :
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        send_gsv_off(); 
//                                             
//                        
//                     break;
//                     
////
///************** turn GPGSV on *************/                        
////                  
//                       
//                    case 'w' :
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        send_gsv_on(); 
//                        
//                       
//                     break;
////
///************* turn GPZDA on *************/                     
////
//                    
//                    case 'z':
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        send_zda_on();
//                        
//                    break;
//                        
////
///************* turn GPGSA off *************/                     
////
//                  
//                    case 'a':
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        send_gsa_off();
//                                               
//                        
//                    break;
////
///************* turn GPGSA on *************/                     
////
//                  
//                    case 'c':
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        send_gsa_on();
//                        
//                                               
//                    break;         
////                    
///************* turn debug on *************/                     
////
//                    case 'd':
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                                          
//                        send_mid105();
//                        
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_buffer_dump(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_buffer_dump(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_buffer_dump(gps_rx_buff,NUM_BYTES);
//                        
//                    break;                   
//                    
//                        
///************* read gps pulse *************/                        
//                     
////
//                    case 'p' :
//
//
//                        while(button){
//
//                         if (pass < 60){
//                            while(!pps){;}    // hold here while pps is low
//                                led_on;    // pps went high
//
//                                gps_fill_buffer(gps_rx_buff,NUM_BYTES); //get gps buffer
//                           //     gps_buffer_dump(gps_rx_buff,NUM_BYTES);
//                                gps_parse_zda(gps_rx_buff, NUM_BYTES, utc_time);
//
//                                 
//                                _DI();
//                                  div1k = (utc_time[9]-0x30)+10*(utc_time[8]-0x30)+100*(utc_time[7]-0x30);
//                                  rtcSec = 10*(utc_time[4]-0x30)+(utc_time[5]-0x30);
//                                  rtcMin = 10*(utc_time[2]-0x30)+(utc_time[3]-0x30);
//                                  rtcHour = 10*(utc_time[0]-0x30)+(utc_time[1]-0x30);
//                                _EI();
//                                                                 
//                                gps_parse_gga(gps_rx_buff, NUM_BYTES, utc_time,
//                                latitude, north_or_south, longitude, east_or_west,
//                                fix_validity, satellites);
//                                gps_parse_rmc(gps_rx_buff, NUM_BYTES, utc_time, 
//                                gprmc_validity, latitude, north_or_south, 
//                                longitude, east_or_west, ut_date);  // parse gprmc
//                               
//                                
//                                  _DI(); 
//                                    rtcMday = 10*(ut_date[0]-0x30)+(ut_date[1]-0x30);
//                                    rtcMon = 10*(ut_date[2]-0x30)+(ut_date[3]-0x30);
//                                    rtcYear = 10*(ut_date[4]-0x30)+(ut_date[5]-0x30)+ 0x7d0; //set rtcc to gps time and date
//                                _EI();   
//                                
//                                     if(gprmc_validity[0] == 0x56)
//                            {
//                                xprintf("GPRMC GPS data is void!\n"); // gps data is invalid
//                                led_off;
//                            }
//                            else if(gprmc_validity[0] == 0x41)
//                            {
//                                xprintf("GPRMC GPS data is valid!\n"); // gps data is valid
//
//
//
//                                    xprintf(" ZDA Synced time is:\n");
//                                    xprintf("%u/%u/%u %02u:%02u:%02u.%03u\n", rtcYear, rtcMon, rtcMday, rtcHour, rtcMin, rtcSec, div1k);
//                                xprintf("GPRMC UTC time is ");
//                                for (i = 0; i < UT_DATE_SIZE; i++){
//                                    xprintf("%c", ut_date[i]);
//                                }
//                                xprintf("  ");
//                                for (i = 0; i < UTC_TIME_SIZE; i++)
//                                {
//                                    xprintf("%c", utc_time[i]);
//                                }
//                                
//                                xprintf("\n");
//                               
//                                 xprintf("Number of satellites is ");
//                            for (i = 0; i < SATELLITES_SIZE; i++)
//                            {
//                                xprintf("%c", satellites[i]);
//                            }
//                            xprintf("\n");
//
//                            
//
//                            pass++;     // only increment when data is valid
//                           
//                                } // end data valid
//                                led_off;
//                                while(pps){;} // stay here until pps goes low
//                                led_off;    // turn led off
//                                if (pass >= 60){
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_shutdown();
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                        gps_fill_buffer(gps_rx_buff,NUM_BYTES);
//                                } // gps shutdown
//
//                         } // do to here if pass < 60
//                           
//                          if (pass >= 60){          // pass >= 10 loop, running off the clock
//                          if(flash){                // flash is set on rtcSec increment
//                           led_on;             // pulse led
//                           Timer4 = 50;
//                           while(Timer4){;}
//                           led_off;
//                           flash = false;           // clear flash
//                           xprintf(" ZDA Synced time is:\n");
//                           xprintf("%u/%u/%u %02u:%02u:%02u.%03u\n", rtcYear, rtcMon, rtcMday, rtcHour, rtcMin, rtcSec, div1k);
//                                 
//                          }  // end flash
//                         }  // end pass >= 10
// 
//                        } // RB10 while loop
//                           
//                        pass = 0;
//                     
//                        break;
////
///************* get gps time and set rtc *************/                                
////                                
//                    case 't' :
//                        // get time and set rtc
//                        for(i = 0; i < NUM_BYTES; ++i)
//                        {
//                            gps_rx_buff[i] = 0x0;
//                        }
//                        Timer4 = 5000;
//                        while (!pps && Timer4){;}
//                      
//                    if (Timer4){                           //1pps received
//              
//                            gps_fill_buffer(gps_rx_buff, NUM_BYTES);
//                            xprintf("gps_rx_buff contents:\n");
//
//                          
//                            gps_buffer_dump(gps_rx_buff, NUM_BYTES);
//                            // Find the message in the buffer
//   
//                            gps_parse_rmc(gps_rx_buff, NUM_BYTES, utc_time, 
//                                    gprmc_validity, latitude, north_or_south, 
//                                    longitude, east_or_west, ut_date);
//                           
////                          // Print out time data
//                            xprintf("\n");
//                            xprintf("GPRMC UTC time is ");
//                            for (i = 0; i < UTC_TIME_SIZE; i++)
//                            {
//                                xprintf("%c", utc_time[i]);
//                            }
//                            xprintf("\n");
//
//                            if(gprmc_validity[0] == 0x56)
//                            {
//                                xprintf("GPRMC GPS data is void!\n");
//                            }
//                            else if(gprmc_validity[0] == 0x41)
//                            {
//                                xprintf("GPRMC GPS data is active!\n");
//                               if (set_time = 0){  
//                                _DI();
//                                div1k = (utc_time[9]-0x30)+10*(utc_time[8]-0x30)+100*(utc_time[7]-0x30);
//                                rtcSec = 10*(utc_time[4]-0x30)+(utc_time[5]-0x30);
//                                rtcMin = 10*(utc_time[2]-0x30)+(utc_time[3]-0x30);
//                                rtcHour = 10*(utc_time[0]-0x30)+(utc_time[1]-0x30);
//                                rtcMday = 10*(ut_date[0]-0x30)+(ut_date[1]-0x30);
//                                rtcMon = 10*(ut_date[2]-0x30)+(ut_date[3]-0x30);
//                                rtcYear = 10*(ut_date[4]-0x30)+(ut_date[5]-0x30)+ 0x7d0;
//                                _EI();
//                                 set_time = 1;
//                               }
//                                
//                            }
//                            
//                             while(pps){;}
//                             while(!pps){;}
//                             
//                                if(pps && !Sec_Pulse){
//                                    _DI();
//                                xprintf("Pulse went high.\n");
//                                div1k = 0;
//                                    if (++rtcSec >= 60) {
//                                        rtcSec = 0;
//                                        if (++rtcMin >= 60) {
//                                            rtcMin = 0;
//                                            if (++rtcHour >= 24) {
//                                                rtcHour = 0;
//                                                n = Month_Days[rtcMon - 1];
//                                                if ((n == 28) && !(rtcYear & 3)) n++;
//                                                if (++rtcMday > n) {
//                                                    rtcMday = 1;
//                                                    if (++rtcMon > 12) {
//                                                        rtcMon = 1;
//                                                        rtcYear++;
//                                                    }
//                                                }
//                                            }
//                                        }
//                                    }
//                                    _EI();
//                                Sec_Pulse = true;
//                                led_on; //turn on led
//                                }
//                            } // end of 1pps received 
//                        
//                    else {
//                        xprintf("Timer timed out.\n");
//                         }
//                    xprintf("set_time is %u\n",set_time);  
//                           
//                    xprintf("Sec_Pulse is %u\n",Sec_Pulse);
//                    
//                            break;  //end of gt
////
///*********** "go" logger start ******************/
////                            
//                       case 'o' :
//                        // get time and set rtc then start logging data
//                           led_off;
//                        for(i = 0; i < NUM_BYTES; ++i)
//                        {
//                            gps_rx_buff[i] = 0x0;
//                        }
//                        Timer4 = 5000;                      //5 second timeout timer
//                        while (!pps && Timer4){;}
//                      
//                    if (Timer4){            //timeout timer still running so 1pps received
//              
//                            gps_fill_buffer(gps_rx_buff, NUM_BYTES); // get gps buffer
//                            xprintf("gps_rx_buff contents:\n");
//
//                          
//                            gps_buffer_dump(gps_rx_buff, NUM_BYTES);
//                            // Find the message in the buffer
//   
//                            gps_parse_rmc(gps_rx_buff, NUM_BYTES, utc_time,  // get location and time
//                                    gprmc_validity, latitude, north_or_south, 
//                                    longitude, east_or_west, ut_date);
//                           
////                          // Print time data
//                            xprintf("\n");
//                            xprintf("GPRMC UTC time is ");
//                            for (i = 0; i < UTC_TIME_SIZE; i++)
//                            {
//                                xprintf("%c", utc_time[i]);
//                            }
//                            xprintf("\n");
//
//                            if(gprmc_validity[0] == 0x56)
//                            {
//                                xprintf("GPRMC GPS data is void!\n"); // gps time is not valid
//                            }
//                            else if(gprmc_validity[0] == 0x41)
//                            {
//                                xprintf("GPRMC GPS data is active!\n"); // gps time is valid so set rtc
//                               if (!set_time){                       // one time through
//                                   _DI();
//                                div1k = (utc_time[9]-0x30)+10*(utc_time[8]-0x30)+100*(utc_time[7]-0x30);
//                                rtcSec = 10*(utc_time[4]-0x30)+(utc_time[5]-0x30);
//                                rtcMin = 10*(utc_time[2]-0x30)+(utc_time[3]-0x30);
//                                rtcHour = 10*(utc_time[0]-0x30)+(utc_time[1]-0x30);
//                                rtcMday = 10*(ut_date[0]-0x30)+(ut_date[1]-0x30);
//                                rtcMon = 10*(ut_date[2]-0x30)+(ut_date[3]-0x30);
//                                rtcYear = 10*(ut_date[4]-0x30)+(ut_date[5]-0x30)+ 0x7d0;
//                                    _EI();
//                                 set_time = 1;
//                               }
//                                
//                            }
//                            
//                             while(pps)                    //allow 1pps signal to pass to capture leading edge of
//                             while(!pps)                             //next pulse
//                             
//                                if(pps && !Sec_Pulse){                      //capture 1pps leading edge
//                                xprintf("Pulse went high.\n");
//                                _DI();
//                                div1k = 0;                                 //clear ms and increment rtc to next second
//                                    if (++rtcSec >= 60) {           
//                                        rtcSec = 0;
//                                        if (++rtcMin >= 60) {
//                                            rtcMin = 0;
//                                            if (++rtcHour >= 24) {
//                                                rtcHour = 0;
//                                                n = Month_Days[rtcMon - 1];
//                                                if ((n == 28) && !(rtcYear & 3)) n++;
//                                                if (++rtcMday > n) {
//                                                    rtcMday = 1;
//                                                    if (++rtcMon > 12) {
//                                                        rtcMon = 1;
//                                                        rtcYear++;
//                                                    }
//                                                }
//                                            }
//                                        }
//                                    }
//                                _EI();
//                                Sec_Pulse = true;                           //rtc has been synchronized to 1pps
//                                led_on;                                //turn on led       
//                                }
//                               //write data file header 
//                            Header_Buffer[0] = 'S';                         //write logger serial number to header buffer
//                            Header_Buffer[1] = 'N';
//                            SN = ldiv(iData,10000);
//                            Header_Buffer[2] = SN.quot + 0x30;
//                            iData = SN.rem;
//                            SN = ldiv(iData,1000);
//                            Header_Buffer[3] = SN.quot + 0x30;
//                            iData = SN.rem;
//                            SN = ldiv(iData,100);
//                            Header_Buffer[4] = SN.quot + 0x30;
//                            SN = ldiv(iData,10);
//                            Header_Buffer[5] = SN.quot + 0x30;
//                            Header_Buffer[6] = SN.rem + 0x30;
//                            for(i=7;i<16;i++){
//                                Header_Buffer[i] = latitude[i-7];           //write latitude to buffer
//                            }
//                            Header_Buffer[i] = north_or_south[0];           //north or south
//                            for(i=17;i<27;i++){
//                                Header_Buffer[i] = longitude[i-17];         //write longitude to buffer
//                            }
//                            Header_Buffer[i] = east_or_west[0];             //east or west
//                            Year = ldiv(rtcYear,100);                       //write year to header//begin at start of new second
//                            Year = ldiv(Year.rem,10);
//                            Header_Buffer[28] = Year.quot + 0x30;
//                            Header_Buffer[29] = Year.rem + 0x30;
//                            Month = ldiv(rtcMon,10);                        //write month to header
//                            Header_Buffer[30] = Month.quot + 0x30;
//                            Header_Buffer[31] = Month.rem + 0x30;
//                            Month_Day = ldiv(rtcMday,10);                   //write day to header
//                            Header_Buffer[32] = Month_Day.quot + 0x30;
//                            Header_Buffer[33] = Month_Day.rem + 0x30;
//                            Hours = ldiv(rtcHour,10);                       //write hour to header
//                            Header_Buffer[34] = Hours.quot + 0x30;
//                            Header_Buffer[35] = Hours.rem + 0x30;
//                            Minutes = ldiv(rtcMin,10);                      //write minute to header
//                            Header_Buffer[36] = Minutes.quot + 0x30;
//                            Header_Buffer[37] = Minutes.rem + 0x30;
//                            Seconds = ldiv(rtcSec,10);                      //write second to header
//                            Header_Buffer[38] = Seconds.quot + 0x30;
//                            Header_Buffer[39] = Seconds.rem + 0x30;
//                            Header_Buffer[40] = '.';
// //                           while(div1k){;}                               // start taking data on the second
//                         //   Hundred_MilliSec = ldiv(div1k,100);     
//                         //   Header_Buffer[42] = Hundred_MilliSec.quot + 0x30;
//                         //   MilliSec = ldiv(Hundred_MilliSec.rem,10);
//                         //   Header_Buffer[43] = MilliSec.quot + 0x30;
//                         //   Header_Buffer[44] = MilliSec.rem + 0x30;
//                            Header_Buffer[41] = 0x30;
//                            Header_Buffer[42] = 0x30;
//                            Header_Buffer[43] = 0x30;
//                            Header_Buffer[47] = ldiv(ls.ms,10).rem + 0x30;     //units
//                            si = ldiv(ls.ms,10).quot;                          //tens,hundreds,thousands
//                            Header_Buffer[46] = ldiv(si,10).rem + 0x30;     //tens
//                            si = ldiv(si,10).quot;                          //hundreds,thousands
//                            Header_Buffer[45] = ldiv(si,10).rem + 0x30;     //hundreds
//                            Header_Buffer[44] = ldiv(ls.ms,1000).quot + 0x30;  //thousands
//                            
//      
//                            fr = f_open(&File[0],"TCdata.dat",FA_WRITE);    //open or create data file
//                            fr = f_lseek(&File[0],f_size(&File[0]));        //create pointer to end of file        
//                            fr = f_write(&File[0],Header_Buffer,48,&bw);    //write header to file
//                            fr = f_close(&File[0]);                         //close the file
//                                                       
//                            Timer4 = ls.ms;
//                            get_ad_chan(ADBuffer);
//                             unsigned char const *TempPtr = (unsigned char const*)(&EngUnits);
//                            for(i=0;i<8;i++)
//                            {    
//                            chan = (ADBuffer[i] & 0x000F) + 1;    
//                            adres = ADBuffer[i] >> 8;
//                            Panel_Temp = GetPanelTemp();
////                            DegC = get_temp(&adres,&Panel_Temp);
//                            index = i * 5;
//                            for (j=0;j<4;j++){
//                            Record_Buffer[index + j] = TempPtr[j];        //DegC;
//                            }
//                            Record_Buffer[index+4] = chan;
//                            }
//                            unsigned char const *PanelTempPtr = (unsigned char const*)(&Panel_Temp); 
//                            index = i * 5;
//                            for (j=0;j<4;j++){
//                            Record_Buffer[index + j] = PanelTempPtr[j];        //DegC;
//                            }
//                            Record_Buffer[index+4] = 0x00;
//                                                       
//                            fr = f_open(&File[0],FileName,FA_WRITE);    //open or create data file
//                            fr = f_lseek(&File[0],f_size(&File[0]));        //create pointer to end of file        
//                            fr = f_write(&File[0],Record_Buffer,45,&bw);    //write header to file
//                            fr = f_close(&File[0]);                         //close the file
//                            
//                    //
//                    //
//                    ///
//                    //
//                    //
//                    //
//                            led_off;
//                            while(!pps)
//                            {
//                            
//                            while(Timer4){;}
//                            Timer4 = ls.ms;
//                            get_ad_chan(ADBuffer);
//                            for(i=0;i<8;i++)
//                            {    
//                            chan = (ADBuffer[i] & 0x000F) + 1;    
//                            adres = ADBuffer[i] >> 8;
//                            Panel_Temp = GetPanelTemp();
//                            EngUnits = process_ad(&adres,&Panel_Temp,(BYTE) ls.measurand[chan - 1]);
//                            
//                            index = i * 5;
//                            for (j=0;j<4;j++){
//                            Record_Buffer[index + j] = TempPtr[j];        //DegC;
//                            }
//                            Record_Buffer[index+4] = chan;
//                            }
//                            unsigned char const *PanelTempPtr = (unsigned char const*)(&Panel_Temp); 
//                            index = i * 5;
//                            for (j=0;j<4;j++){
//                            Record_Buffer[index + j] = PanelTempPtr[j];        //DegC;
//                            }
//                            Record_Buffer[index+4] = 0x00;
//                            fr = f_open(&File[0],FileName,FA_WRITE);    //open or create data file
//                            fr = f_lseek(&File[0],f_size(&File[0]));        //create pointer to end of file        
//                            fr = f_write(&File[0],Record_Buffer,45,&bw);    //write header to file
//                            fr = f_close(&File[0]); 
//                                                        
//                            }
//                            led_on;
//                            } // end of 1pps received 
//                        
//                    else {
//                        xprintf("Timer timed out.\n");
//                         }
//                    xprintf("set_time is %u\n",set_time);  
//                           
//                    xprintf("Sec_Pulse is %u\n",Sec_Pulse);
//                    //
//                    
//                     
//                
//                            break;  //end of go
////
///******** get gps buffer ****************/                            
////                            
//                        
//                    case 'b' :
//                        // Clear out the buffer
//                        for(i = 0; i < NUM_BYTES; ++i)
//                        {
//                            gps_rx_buff[i] = 0x0;
//                        }
//  
//                        // fill the receive buffer
//                        find_message_success = 1;
//                        while(find_message_success != 0)
//                        {
//                            gps_fill_buffer(gps_rx_buff, NUM_BYTES);
//                            xprintf("gps_rx_buff contents:\n");
//
//                              
//                            gps_buffer_dump(gps_rx_buff, NUM_BYTES);
//                            // Find the message in the buffer
//   
//                            gps_parse_rmc(gps_rx_buff, NUM_BYTES, utc_time, 
//                                    gprmc_validity, latitude, north_or_south, 
//                                    longitude, east_or_west, ut_date);
//                           
//
//                            // Print out time data
//                            xprintf("\n");
//                            xprintf("GPRMC UTC time is ");
//                            for (i = 0; i < UTC_TIME_SIZE; i++)
//                            {
//                                xprintf("%c", utc_time[i]);
//                            }
//                            xprintf("\n");
//
//                            if(gprmc_validity[0] == 0x56)
//                            {
//                                xprintf("GPRMC GPS data is void!\n");
//                            }
//                            else if(gprmc_validity[0] == 0x41)
//                            {
//                                xprintf("GPRMC GPS data is valid!\n");
//
//                                
//                            }
//                           
//                            // Print RMC GPS latitude                            
//                            xprintf("GPRMC latitude is ");
//                            for (i = 0; i < LATITUDE_SIZE; i++)
//                            {
//                                xprintf("%c", latitude[i]);
//                            }
//                            xprintf("\n");
//
//                            // Print RMC GPS North or South
//                            xprintf("GPRMC North or South is %c\n", north_or_south[0]);
//
//                            // Print RMC GPS longitude
//                            xprintf("GPRMC longitude is ");
//                            for (i = 0; i < LONGITUDE_SIZE; i++)
//                            {
//                                xprintf("%c", longitude[i]);
//                            }
//                            xprintf("\n");
//
//                            // Print RMC GPS East or West
//                            xprintf("GPRMC East or West is %c\n", east_or_west[0]);
//                            
//                            // Print RMC GPS UT date
//                            xprintf("GPRMC UT date is ");
//                            for (i = 0; i < UT_DATE_SIZE; i++)
//                            {
//                                if(i == 2 || i == 4)
//                                {
//                                     xprintf("/");
//                                }
//                                xprintf("%c", ut_date[i]);
//                            }
//                            xprintf("\n");
//                            
//                           
//                            gps_parse_gga( gps_rx_buff, NUM_BYTES, utc_time,
//                                    latitude, north_or_south, longitude,
//                                     east_or_west, fix_validity, satellites);
//                            
//                            xprintf("Number of satellites is ");
//                            for (i = 0; i < SATELLITES_SIZE; i++)
//                            {
//                                xprintf("%c", satellites[i]);
//                            }
//                            xprintf("\n");
//                                          
//                            x = atoi(satellites);
//                                                        
//                          
//                            break; // end case 'gb'
//                        }
//                            
//                    break; // end case 'g'
//                }
////
///************* start of a/d routines **************/                
////                
//                case 'a' :  // A/D routines
//                    switch (*ptr++) {
////
///************* get 8 channels of thermocouple data and convert to temperatures *************/                        
////
//                        case 'd' :    
//                            if (!xatoi(&ptr,&p1)) break;
//                            if((p1<0) | (p1>7)) break;
//                            /*adres = get_ad_id();*/
//                            get_ad_chan(ADBuffer);
//                            //adres = get_ad_chan((BYTE)p1);
//                            unsigned char const *TempPtr = (unsigned char const*)(&EngUnits);
//                            for(i=0;i<8;i++)
//                            {    
//                            chan = (ADBuffer[i] & 0x000F) + 1;    //channel number in byte 4 of 32 bit result
//                            adres = ADBuffer[i] >> 8; //right shift result by 8 bits to get rid of channel number
//                            Panel_Temp = GetPanelTemp(); //convert lm20 result to temperature
//                            EngUnits = process_ad(&adres,&Panel_Temp, (BYTE) ls.measurand[chan - 1]); //convert TC result to temperature using panel temperature
//                            index = i * 5; //index to next TC channel
//                            for (j=0;j<4;j++){
//                            Record_Buffer[index + j] = TempPtr[j];  //get next channel result from record buffer
//                            }
//                            Record_Buffer[index+4] = chan; //pull channel number out of result
//                            xprintf("AD#:%u, Reading:%lu\n",(BYTE)chan,adres);
//                            printf("Temp: %.1f\n",EngUnits);
//                            printf("Panel Temp: %.1f\n",(double)Panel_Temp);
//                            }
//                            unsigned char const *PanelTempPtr = (unsigned char const*)(&Panel_Temp); 
//                            index = i * 5;
//                            for (j=0;j<4;j++){
//                            Record_Buffer[index + j] = PanelTempPtr[j];        //DegC;
//                            }
//                            Record_Buffer[index+4] = 0x00;
//                            break; //end of ad
////
///****************** get a/d id ********************/                            
////                            
//                            
//                        case 'i' : 
//                            
//                            
//                            adres = get_ad_id(arg);
//                            xprintf("ID#:%lu\n",adres);
//                            
//                            xprintf("Arg after address query\n");
//                            xprintf("%02X",arg);
//                            xprintf("\n");
//                          
//                            break;// end of ai
////
///*******************a/d shutdown ******************************/
////
//                        case 's':
//                            ad_power_off();
//                            
//                            break;//end of as
////
///******************a/d initialize ****************************/
////
//                            
//                        case 'b':
//                            ad_init();
//                            break;//end of a/d initialize
//                                                             
////
///**************** create header for data file *****************/
////                            
//                        case 'f' :
//                            Header_Buffer[0] = 'S';
//                            Header_Buffer[1] = 'N';
//                            SN = ldiv(iData,10000);
//                            Header_Buffer[2] = SN.quot + 0x30;
//                            iData = SN.rem;
//                            SN = ldiv(iData,1000);
//                            Header_Buffer[3] = SN.quot + 0x30;
//                            iData = SN.rem;
//                            SN = ldiv(iData,100);
//                            Header_Buffer[4] = SN.quot + 0x30;
//                            SN = ldiv(iData,10);
//                            Header_Buffer[5] = SN.quot + 0x30;
//                            Header_Buffer[6] = SN.rem + 0x30;
//                            for(i=8;i<17;i++){
//                                Header_Buffer[i] = latitude[i-8];
//                            }
//                            Header_Buffer[i] = north_or_south[0];
//                            for(i=18;i<28;i++){
//                                Header_Buffer[i] = longitude[i-19];
//                            }
//                            Header_Buffer[i] = east_or_west[0];
//                            Year = ldiv(rtcYear,100);                       //write year to header//begin at start of new second
//                            Year = ldiv(Year.rem,10);
//                            Header_Buffer[28] = Year.quot + 0x30;
//                            Header_Buffer[29] = Year.rem + 0x30;
//                            Month = ldiv(rtcMon,10);                        //write month to header
//                            Header_Buffer[30] = Month.quot + 0x30;
//                            Header_Buffer[31] = Month.rem + 0x30;
//                            Month_Day = ldiv(rtcMday,10);                   //write day to header
//                            Header_Buffer[32] = Month_Day.quot + 0x30;
//                            Header_Buffer[33] = Month_Day.rem + 0x30;
//                            Hours = ldiv(rtcHour,10);
//                            Header_Buffer[35] = Hours.quot + 0x30;
//                            Header_Buffer[36] = Hours.rem + 0x30;
//                            Minutes = ldiv(rtcMin,10);
//                            Header_Buffer[37] = Minutes.quot + 0x30;
//                            Header_Buffer[38] = Minutes.rem + 0x30;
//                            Seconds = ldiv(rtcSec,10);
//                            Header_Buffer[39] = Seconds.quot + 0x30;
//                            Header_Buffer[40] = Seconds.rem + 0x30;
//                            Header_Buffer[41] = '.';
//                            while(div1k != 456)
//                            Hundred_MilliSec = ldiv(div1k,100);
//                            Header_Buffer[42] = Hundred_MilliSec.quot + 0x30;
//                            MilliSec = ldiv(Hundred_MilliSec.rem,10);
//                            Header_Buffer[43] = MilliSec.quot + 0x30;
//                            Header_Buffer[44] = MilliSec.rem + 0x30;
//                            
////                            p1 = 0;
////
////                              for(p2 = 0;p2 < 8400;p2++) {
////                                                 
////                                 Timer4 = ms;
////                                
////                                 if(p1 == 0)
////                                 {
////                                 Buff[p1] = 0x00;
////                                 Buff[p1+1] = (ms  & 0x000000FF);
////                                 Buff[p1+2] = ((ms >> 8) & 0x000000FF);
////                                 Buff[p1+3] = ((ms >> 16) & 0x000000FF);
////                                 CTime = get_fattime();
////                                 Buff[p1+4] = (CTime & 0x000000FF);
////                                 Buff[p1+5] = ((CTime >> 8) & 0x000000FF);
////                                 Buff[p1+6] = ((CTime >> 16) & 0x000000FF);
////                                 Buff[p1+7] = ((CTime >> 24) & 0x000000FF);
////
////                                 p1 = 6;
////                                 }
////
////
////                        for(n=0;n<3;n++)
////                        {
////                     //   adres = get_ad_chan((BYTE)n);
////                     //   Ten_degC = get_temp(adres);
////                        p1+=2;
////                        Buff[p1] = (Ten_degC & 0x00FF);
////                        Buff[p1+1] = ((Ten_degC >> 8) & 0x00FF);
////
////                        }
////                        if(p1 > 504)
////                        {
////                        fr = f_open(&File[0],"TCdata.dat",FA_WRITE);
////                        fr = f_lseek(&File[0],f_size(&File[0]));
////                        fr = f_write(&File[0],Buff,512,&bw);
////                        fr = f_close(&File[0]);
////                        p1 = 0;
////                        }
////                            if(!Timer4)
////                            {
////                            xprintf("Loop time out. %lu\n", (BYTE)p1);
////                            
////                            }
////                            while(Timer4);
////                       }
//                            break; //end of af
//                    }
//                    break; // end of a
//                    
////
///********** start of disk routines **************/                    
////                    
//		case 'd' :
//			switch (*ptr++) {
////
///********** dump sector data *******************/
////                
//			case 'd' :	/* dd [<pd#> <sector>] - Dump sector */
//				if (xatoi(&ptr, &p1)) {
//					if (!xatoi(&ptr, &p2)) break;
//				} else {
//					p1 = drv; p2 = sect;
//				}
//				b = disk_read((BYTE)p1, Buff, p2, 1);
//				if (b) { xprintf("rc=%d\n", b); break; }
//				drv = (BYTE)p1; sect = p2 + 1;
//				xprintf("PD#:%u, Sector:%lu\n", (BYTE)p1, p2);
//				for (ptr=(char*)Buff, ofs = 0; ofs < 0x200; ptr += 16, ofs += 16)
//					put_dump((BYTE*)ptr, ofs, 16, DW_CHAR);
//				break;
////
///********** initialize physical drive ***************/
////                
//			case 'i' :	/* di <pd#> - Initialize physical drive */
//				if (!xatoi(&ptr, &p1)) break;
//				xprintf("rc=%d\n", disk_initialize((BYTE)p1));
//				break;
////
///********** show disk status **********************/
////                
//			case 's' :	/* ds <pd#> - Show disk status */
//				if (!xatoi(&ptr, &p1)) break;
//				if (disk_ioctl((BYTE)p1, GET_SECTOR_COUNT, &p2) == RES_OK)
//					{ xprintf("Drive size: %lu sectors\n", p2); }
//				if (disk_ioctl((BYTE)p1, GET_BLOCK_SIZE, &p2) == RES_OK)
//					{ xprintf("Erase block: %lu sectors\n", p2); }
//				if (disk_ioctl((BYTE)p1, MMC_GET_TYPE, &b) == RES_OK)
//					{ xprintf("MMC/SDC type: %u\n", b); }
//				if (disk_ioctl((BYTE)p1, MMC_GET_CSD, Buff) == RES_OK)
//					{ xputs("CSD:\n"); put_dump(Buff, 0, 16, DW_CHAR); }
//				if (disk_ioctl((BYTE)p1, MMC_GET_CID, Buff) == RES_OK)
//					{ xputs("CID:\n"); put_dump(Buff, 0, 16, DW_CHAR); }
//				if (disk_ioctl((BYTE)p1, MMC_GET_OCR, Buff) == RES_OK)
//					{ xputs("OCR:\n"); put_dump(Buff, 0, 4, DW_CHAR); }
//				if (disk_ioctl((BYTE)p1, MMC_GET_SDSTAT, Buff) == RES_OK) {
//					xputs("SD Status:\n");
//					for (s1 = 0; s1 < 64; s1 += 16) put_dump(Buff+s1, s1, 16, DW_CHAR);
//				}
//				break;
//			}
//			break;
////
///********** dump R/W buffer *************/
////            
//		case 'b' :
//			switch (*ptr++) {
//			case 'd' :	/* bd <ofs> - Dump R/W buffer */
//				if (!xatoi(&ptr, &p1)) break;
//				for (ptr=(char*)&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr += 16, ofs += 16)
//					put_dump((BYTE*)ptr, ofs, 16, DW_CHAR);
//				break;
////
///********** edit R/W buffer ************/                
////                
//			case 'e' :	/* be <ofs> [<data>] ... - Edit R/W buffer */
//				if (!xatoi(&ptr, &p1)) break;
//				if (xatoi(&ptr, &p2)) {
//					do {
//						Buff[p1++] = (BYTE)p2;
//					} while (xatoi(&ptr, &p2));
//					break;
//				}
//				for (;;) {
//					xprintf("%04X %02X-", (WORD)p1, Buff[p1]);
//					xgets(Line, sizeof Line);
//					ptr = Line;
//					if (*ptr == '.') break;
//					if (*ptr < ' ') { p1++; continue; }
//					if (xatoi(&ptr, &p2))
//						Buff[p1++] = (BYTE)p2;
//					else
//						xputs("???\n");
//				}
//				break;
////
///********** read disk into R/W buffer ************/                
////                
//			case 'r' :	/* br <pd#> <sector> <count> - Read disk into R/W buffer */
//				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
//				xprintf("rc=%u\n", disk_read((BYTE)p1, Buff, p2, (BYTE)p3));
//				break;
////
///********** write R/W buffer to disk ************/                
////                
//			case 'w' :	/* bw <pd#> <sector> <count> - Write R/W buffer into disk */
//				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
//				xprintf("rc=%u\n", disk_write((BYTE)p1, Buff, p2, (BYTE)p3));
//				break;
////
///********** fill working buffer with character ********/                
////                
//			case 'f' :	/* bf <n> - Fill working buffer */
//				if (!xatoi(&ptr, &p1)) break;
//				memset(Buff, (int)p1, sizeof Buff);
//				break;
//
//			}
//			break;
////
///********** file routines ************/            
////            
//		case 'f' :
//			switch (*ptr++) {
////
///********** initialize logical drive *********/                
////                
//			case 'i' :	/* fi [<mount>] - Force initialized the logical drive */
//				if (!xatoi(&ptr, &p2)) p2 = 0;
//				put_rc(f_mount(&FatFs, "", (BYTE)p2));
//				break;
////
///********** logical drive status ************/                
////                
//			case 's' :	/* fs [<path>] - Show logical drive status */
//				while (*ptr == ' ') ptr++;
//				res = f_getfree(ptr, (DWORD*)&p2, &fs);
//				if (res) { put_rc(res); break; }
//				xprintf("FAT type = FAT%u\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
//						"Root DIR entries = %u\nSectors/FAT = %lu\nNumber of clusters = %lu\n"
//						"Volume start (lba) = %lu\nFAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n\n...",
//						ft[fs->fs_type & 3], fs->csize * 512UL, fs->n_fats,
//						fs->n_rootdir, fs->fsize, fs->n_fatent - 2,
//						fs->volbase, fs->fatbase, fs->dirbase, fs->database
//				);
//				AccSize = AccFiles = AccDirs = 0;
//				res = scan_files(ptr);
//				if (res) { put_rc(res); break; }
//				xprintf("\r%u files, %lu bytes.\n%u folders.\n"
//						"%lu KiB total disk space.\n%lu KiB available.\n",
//						AccFiles, AccSize, AccDirs,
//						(fs->n_fatent - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
//				);
//				break;
////
///********** directory listing ************/                
////                
//			case 'l' :	/* fl [<path>] - Directory listing */
//				while (*ptr == ' ') ptr++;
//				res = f_opendir(&dir, ptr);
//				if (res) { put_rc(res); break; }
//				p1 = s1 = s2 = 0;
//				for(;;) {
//					res = f_readdir(&dir, &Finfo);
//					if ((res != FR_OK) || !Finfo.fname[0]) break;
//					if (Finfo.fattrib & AM_DIR) {
//						s2++;
//					} else {
//						s1++; p1 += Finfo.fsize;
//					}
//					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %-12s  %s\n",
//							(Finfo.fattrib & AM_DIR) ? 'D' : '-',
//							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
//							(Finfo.fattrib & AM_HID) ? 'H' : '-',
//							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
//							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
//							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
//							(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63, Finfo.fsize, Finfo.fname,
//#if _USE_LFN
//							Lfname);
//#else
//							"");
//#endif
//				}
//				xprintf("%4u File(s),%10lu bytes total\n%4u Dir(s)", s1, p1, s2);
//				if (f_getfree(ptr, (DWORD*)&p1, &fs) == FR_OK)
//					xprintf(", %10lu bytes free\n", p1 * fs->csize * 512);
//				break;
//#if _USE_FIND
////
///************** directory search *******************/                
////                
//			case 'L' :	/* fL <path> <pattern> - Directory search */
//				while (*ptr == ' ') ptr++;
//				ptr2 = ptr;
//				while (*ptr != ' ') ptr++;
//				*ptr++ = 0;
//				res = f_findfirst(&dir, &Finfo, ptr2, ptr);
//				while (res == FR_OK && Finfo.fname[0]) {
//					xprintf("%s", Finfo.fname);
//#if _USE_LFN
//					for (p2 = strlen(Finfo.fname); p2 < 12; p2++) xprintf(" ");
//					xprintf("  %s", Lfname); 
//#endif
//					xprintf("\n");
//					res = f_findnext(&dir, &Finfo);
//				}
//				if (res) put_rc(res);
//				f_closedir(&dir);
//				break;
//#endif
////
///************** open file ************/                
////                
//                case 'o' :	/* fo <mode> <file> - Open a file */
//				if (!xatoi(&ptr, &p1)) break;
//				while (*ptr == ' ') ptr++;
//				put_rc(f_open(&File[0], ptr, (BYTE)p1));
//				break;
////
///************** close file ************/                
////                
//			case 'c' :	/* fc - Close a file */
//				put_rc(f_close(&File[0]));
//				break;
////
///************** seek file pointer *************/                
////                
//			case 'e' :	/* fe <ofs> - Seek file pointer */
//				if (!xatoi(&ptr, &p1)) break;
//				res = f_lseek(&File[0], p1);
//				put_rc(res);
//				if (res == FR_OK)
//					xprintf("fptr = %lu(0x%lX)\n", f_tell(&File[0]), f_tell(&File[0]));
//				break;
////
///************** read file ************/                
////                
//			case 'r' :	/* fr <len> - read file */
//				if (!xatoi(&ptr, &p1)) break;
//				p2 = 0;
//				Timer = 0;
//				while (p1) {
//					if ((DWORD)p1 >= sizeof Buff) {
//						cnt = sizeof Buff; p1 -= sizeof Buff;
//					} else {
//						cnt = p1; p1 = 0;
//					}
//					res = f_read(&File[0], Buff, cnt, &s2);
//					if (res != FR_OK) { put_rc(res); break; }
//					p2 += s2;
//					if (cnt != s2) break;
//				}
//				xprintf("%lu bytes read with %lu kB/sec.\n", p2, Timer ? (p2 / Timer) : 0);
//				break;
////
///************** read and dump file from current file pointer *************/                
////                
//			case 'd' :	/* fd <len> - read and dump file from current fp */
//				if (!xatoi(&ptr, &p1)) break;
//				ofs = f_tell(&File[0]);
//				while (p1) {
//					if ((UINT)p1 >= 16) { cnt = 16; p1 -= 16; }
//					else 				{ cnt = p1; p1 = 0; }
//					res = f_read(&File[0], Buff, cnt, &cnt);
//					if (res != FR_OK) { put_rc(res); break; }
//					if (!cnt) break;
//					put_dump(Buff, ofs, cnt, DW_CHAR);
//					ofs += 16;
//				}
//				break;
////
///************** file write **************/                
////                
//			case 'w' :	/* fw <len> <val> - write file */
//				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
//				memset(Buff, (int)p2, sizeof Buff);
//				p2 = 0;
//				Timer = 0;
//				while (p1) {
//					if ((DWORD)p1 >= sizeof Buff) {
//						cnt = sizeof Buff; p1 -= sizeof Buff;
//					} else {
//						cnt = p1; p1 = 0;
//					}
//					res = f_write(&File[0], Buff, cnt, &s2);
//					if (res != FR_OK) { put_rc(res); break; }
//					p2 += s2;
//					if (cnt != s2) break;
//				}
//				xprintf("%lu bytes written with %lu kB/sec.\n", p2, Timer ? (p2 / Timer) : 0);
//				break;
////
///************** change name of file *************/                
////                
//			case 'n' :	/* fn <old_name> <new_name> - Change file/dir name */
//				while (*ptr == ' ') ptr++;
//				ptr2 = strchr(ptr, ' ');
//				if (!ptr2) break;
//				*ptr2++ = 0;
//				while (*ptr2 == ' ') ptr2++;
//				put_rc(f_rename(ptr, ptr2));
//				break;
////
///************** unlink file or directory ***************/ 
////                
//			case 'u' :	/* fu <path> - Unlink a file or dir */
//				while (*ptr == ' ') ptr++;
//				put_rc(f_unlink(ptr));
//				break;
////
///************** truncate file **************/                
////                
//			case 'v' :	/* fv - Truncate file */
//				put_rc(f_truncate(&File[0]));
//				break;
////
///************** create directory *************/                
////                
//			case 'k' :	/* fk <path> - Create a directory */
//				while (*ptr == ' ') ptr++;
//				put_rc(f_mkdir(ptr));
//				break;
////
///************** change file attribute **************/                
////                
//			case 'a' :	/* fa <atrr> <mask> <name> - Change file/dir attribute */
//				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
//				while (*ptr == ' ') ptr++;
//				put_rc(f_chmod(ptr, p1, p2));
//				break;
////
///************** change file timestamp **************/                
////                
//			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp */
//				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
//				Finfo.fdate = (WORD)(((p1 - 2016) << 9) | ((p2 & 15) << 5) | (p3 & 31));
//				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
//				Finfo.ftime = (WORD)(((p1 & 31) << 11) | ((p1 & 63) << 5) | ((p1 << 0) & 31));
//				put_rc(f_utime(ptr, &Finfo));
//				break;
////
///************** copy file ************/                
////                
//			case 'x' : /* fx <src_name> <dst_name> - Copy file */
//				while (*ptr == ' ') ptr++;
//				ptr2 = strchr(ptr, ' ');
//				if (!ptr2) break;
//				*ptr2++ = 0;
//				while (*ptr2 == ' ') ptr2++;
//				xprintf("Opening \"%s\"", ptr);
//				res = f_open(&File[0], ptr, FA_OPEN_EXISTING | FA_READ);
//				xputc('\n');
//				if (res) {
//					put_rc(res);
//					break;
//				}
//				xprintf("Creating \"%s\"", ptr2);
//				res = f_open(&File[1], ptr2, FA_CREATE_ALWAYS | FA_WRITE);
//				xputc('\n');
//				if (res) {
//					put_rc(res);
//					f_close(&File[0]);
//					break;
//				}
//				xprintf("Copying...");
//				p1 = 0;
//				for (;;) {
//					res = f_read(&File[0], Buff, sizeof Buff, &s1);
//					if (res || s1 == 0) break;   /* error or eof */
//					res = f_write(&File[1], Buff, s1, &s2);
//					p1 += s2;
//					if (res || s2 < s1) break;   /* error or disk full */
//				}
//				xprintf("\n%lu bytes copied.\n", p1);
//				f_close(&File[0]);
//				f_close(&File[1]);
//				break;
//#if _FS_RPATH >= 1
////
///************** change current directory **************/                
////                
//			case 'g' :	/* fg <path> - Change current directory */
//				while (*ptr == ' ') ptr++;
//				put_rc(f_chdir(ptr));
//				break;
//#if _FS_RPATH >= 2
////
///************** show current directory path *************/                
////                
//                case 'q' :	/* fq - Show current dir path */
//				res = f_getcwd(Line, sizeof Line);
//				if (res)
//					put_rc(res);
//				else
//					xprintf("%s\n", Line);
//				break;
//#endif
//#endif
//#if _USE_MKFS
////
///************** format drive ************/                
////                
//			case 'm' :	/* fm <partition rule> <sect/clust> - Create file system */
//				if (!xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
//				xprintf("The memory card will be formatted. Are you sure? (Y/n)=", p1);
//				xgets(Line, sizeof Line);
//				if (Line[0] == 'Y')
//					put_rc(f_mkfs("", (BYTE)p2, (WORD)p3));
//				break;
//#endif
//			}
//			break;
////
///************** print current time *************/            
////            
//		case 't' :		/* t [<year> <mon> <mday> <hour> <min> <sec>] */
//			if (xatoi(&ptr, &p1)) {
//				rtcYear = p1;
//				xatoi(&ptr, &p1); rtcMon = p1-1;
//				xatoi(&ptr, &p1); rtcMday = p1;
//				xatoi(&ptr, &p1); rtcHour = p1;
//				xatoi(&ptr, &p1); rtcMin = p1;
//				if(!xatoi(&ptr, &p1)) break;
//				rtcSec = p1;
//			}
//			xprintf("%u/%u/%u %02u:%02u:%02u\n", rtcYear, rtcMon, rtcMday, rtcHour, rtcMin, rtcSec);
//			break;
//		}
//	}
   }


